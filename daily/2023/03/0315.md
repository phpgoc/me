| 序号  | 内容                                                                                                                                                                                                                                                                         | 来源      | 备注      | 类型        |
|:---:|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:--------|:--------|:----------|
|  1  | 许式伟的架构课                                                                                                                                                                                                                                                                    | 极客时间    | 不行，干货太少 | course    |
|  2  | CPU指令分类：算术指令、逻辑指令、移位指令、传送指令、控制指令、输入输出指令、其他指令                                                                                                                                                                                                                               | 许式伟的架构课 |         | tip       |
|  3  | 消息传递约束了进程（这里的进程是抽象意义上的，在 Go 语言中叫 goroutine）的行为，是进程与进程的连接契约。消息传递是多核背景下流行起来的一种编程思想，其核心主张是：尽可能用消息传递来取代共享内存，从而尽可能避免显式的锁，降低编程负担。                                                                                                                                                | 许式伟的架构课 | 30      | pointview |
|  4  | go不是为了避免锁，而是没法用锁。如果锁是可能的，锁的性能比消息传递好多了。携程调度和mutex抢锁在go的模型下没法共存，一定会有很多死锁和内存安全问题。                                                                                                                                                                                             |         | 50      | summary   |
|  5  | 函数式编程里面，需要通过一种复杂的平衡二叉树来实现一个使用界面（接口）上和过程式语言数组一致的“数组”。这个简单的例子表明，如果你想用函数式编程，你需要重修数据结构这门课程，大学里面学的数据结构是不顶用了                                                                                                                                                                     | 许式伟的架构课 |         | tip       |
|  6  | 内存的全局有一个中断向量表，本质上就是在一个大家公认的地方放了一堆函数地址。比如键盘按了一个键，它会触发 9 号中断。在 CPU 收到中断请求时，它会先停下手头的活来响应中断请求（到中断向量表找到第 9 项对应的函数地址并去执行它），完成后再回去干原来的活                                                                                                                                           | 许式伟的架构课 |         | tip       |
|  7  | 保护模式下，内存访问不再是直接通过物理内存，而是基于虚拟内存。虚拟内存模式下，整个内存空间被分成很多个连续的内存页。每个内存页大小是固定的，比如 64K。                                                                                                                                                                                              | 许式伟的架构课 |         | tip       |
|  8  | 缺页的中断请求会被操作系统接管。发生缺页时，操作系统会为这个内存页分配物理的内存，并恢复这个内存页的数据。如果没有空闲的物理内存可以分配，它就会选择一个最久没有被访问的内存页进行淘汰                                                                                                                                                                                | 许式伟的架构课 |         | tip       |
|  9  | dylib（Mach-O Dynamic Library                                                                                                                                                                                                                                               | 许式伟的架构课 |         | tip       |
| 10  | 但事实证明 UNIX 错了。输入输出设备太多样化了，所谓的 “一切皆文件” 不过是象牙塔式的理想                                                                                                                                                                                                                           | 许式伟的架构课 | 60      | pointview |
| 11  | 方法是把 CPU 的时间切成一段段时间片，每个时间片只运行某一个软件。这个时间片给软件 A，下一个时间片给软件 B。因为时间片很小，我们会感觉这些软件同时都在运行。这种分时间片实现的多任务系统，我们把它叫分时系统。                                                                                                                                                                | 许式伟的架构课 |         | tip       |
| 12  | 系统调用机制产生的开销很大.但这是很大的误解。系统调用虽然比函数调用多做了一点点事情，比如查询了中断向量表（这类似编程语言中的虚函数），比如改变 CPU 的执行权限（从用户态跃迁到内核态再回到用户态）。但是注意这里并没有发生过调度行为，所以归根结底还是一次函数调用的成本。                                                                                                                                   | 许式伟的架构课 |         | tip       |
| 13  | 同步原语，信号量这样的同步原语，我们这里没有交代，这是因为它被更强大而且性能更好的同步原语 “条件变量” 所取代了                                                                                                                                                                                                                  | 许式伟的架构课 | 30      | pointview |
| 14  | C++ 的信号量(latch,barrier)是C++20才有的；条件变量since c++11。条件变量代替信号量的说法有些怀疑                                                                                                                                                                                                          |         |         | answer    |
| 15  | 信号量（Semaphore）概念是 Dijkstra（学过数据结构可能会立刻回忆起图的最短路径算法，对的，就是他发明的）提出来的。信号量本身是一个整型数值，代表着某种共享资源的数量（简记为 S）。信号量的操作界面为 PV 操作。<br/>P 操作意味着请求或等待资源。执行 P 操作 P(S) 时，S 的值减 1，如果 S < 0，说明没有资源可用，等待其他执行体释放资源。<br/>V 操作意味着释放资源并唤醒执行体。执行 V 操作 V(S) 时，S 的值加 1，如果 S <= 0，则意味着有其他执行体在等待中，唤醒其中的一个。 | 许式伟的架构课 |         | tip       |
| 16  | UNIX 还发明了一个专门用于本地通讯的套接字：UNIX 域。UNIX 域不同于常规套接字的是，它通过一个 name 来作为访问地址，而不是用ip:port来作为访问地址。                                                                                                                                                                                     | 许式伟的架构课 |         | tip       |

![c v go ](https://static001.geekbang.org/resource/image/37/11/372f60e314a3ec386844d4cd1db74411.jpg?wh=612*898)
![常见文件系统](https://static001.geekbang.org/resource/image/07/29/0795b3e4c850d2201269be0412c45c29.jpg?wh=1321*580)
![进程内同步](https://static001.geekbang.org/resource/image/57/1b/575d31c0ebf3f4a6148a211387bdae1b.jpg?wh=613*571)