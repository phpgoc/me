| 序号 | 内容                                                                                                                                                                                 | 来源                    | 备注                                                      | 类型   |
|:--:|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:----------------------|:--------------------------------------------------------|:-----|
| 1  | 作为库里的函数，应该假设用户会在多线程环境下调用，所以应该考虑是否使用std::mutex来保护静态变量，或者考虑thread local                                                                                                              | C++ Core Guidelines解析 |                                                         | tip  |
| 2  | 当两个线程并发访问同一个对象时，如果其中一个线程是写操作，那么这两个线程之间就存在数据竞争，如果其中一个线程是写操作，那么这两个线程之间就存在数据竞争，数据竞争对C++标准来说是未定义行为                                                                                     | C++ Core Guidelines解析 |                                                         | tip  |
| 3  | ThreadSanitizer是一个动态分析工具，可以检测数据竞争，但是会降低程序的性能，所以只在调试时使用，不要在生产环境使用，因为它会降低程序的性能                                                                                                       | C++ Core Guidelines解析 |                                                         | tip  |
| 4  | ThreadSanitizer 是gcc，clang自带的                                                                                                                                                      | C++ Core Guidelines解析 |                                                         | tip  |
| 5  | CppMem是一个静态分析工具                                                                                                                                                                    | C++ Core Guidelines解析 |                                                         | tip  |
| 6  | Mathematizing C++ Concurrency 数学化C++并发，这本书是讲如何使用数学的方法来分析C++的并发问题，比如使用数学的方法来分析死锁，使用数学的方法来分析数据竞争，使用数学的方法来分析内存泄漏                                                                      | C++ Core Guidelines解析 | http://www.cl.cam.ac.uk/~pes20/cpp/popl085ap-sewell.pdf | book | 
| 7  | 如果一个线程持有多个互斥量，务必用相同的顺序来获取互斥量，lock_guard,否则会死锁                                                                                                                                      | C++ Core Guidelines解析 |                                                         | tip  |
| 8  | 解决死锁的根本方法，可以原子的方式同时获取多个互斥量，std::lock, std::scoped_lock, std::unique_lock, std::shared_lock, std::lock_guard, std::scoped_lock, std::unique_lock, std::shared_lock, std::lock_guard | C++ Core Guidelines解析 |                                                         | tip  |
| 9  | 优先使用jthread，jthread会在析构时自动join                                                                                                                                                     | C++ Core Guidelines解析 |                                                         | tip  |
| 10 | 条件变量可以不使用谓词，代价是可能会丢失唤醒和虚假唤醒                                                                                                                                                        | C++ Core Guidelines解析 |                                                         | tip  |
| 11 | 丢失唤醒：发送方在接收方还没有等待之前就发送了通知                                                                                                                                                          | C++ Core Guidelines解析 |                                                         | tip  |
| 12 | 虚假唤醒：接收方在没有接收到通知的情况下就醒来了                                                                                                                                                           | C++ Core Guidelines解析 |                                                         | tip  |
| 13 | x86,amd64上，操作重排相当保守，只支持StoreLoad，在其他架构中4种重排都支持                                                                                                                                     | C++ Core Guidelines解析 |                                                         | tip  |
| 14 | 强异常安全：提交或回滚语义                                                                                                                                                                      | C++ Core Guidelines解析 |                                                         | tip  |
| 15 | 基本异常安全：不泄漏资源                                                                                                                                                                       | C++ Core Guidelines解析 |                                                         | tip  |
| 16 | 在直接拥有对象时绝不抛出异常，new int，throw 1，会导致内存泄漏                                                                                                                                             | C++ Core Guidelines解析 |                                                         | tip  |
| 17 | mutable的意义， mutable std::mutex m;  const函数依然保留语义，互斥量的可变不该影响类的不可变性                                                                                                                  | C++ Core Guidelines解析 |                                                         | tip  |

