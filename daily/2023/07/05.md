| 序号 | 内容                                                  | 来源                  | 备注             | 类型   |
|:--:|:----------------------------------------------------|:--------------------|:---------------|:-----|
| 1  | 单条指令的解码逻辑，先读取操作码，然后根据操作码读取操作数，最后执行指令                | WebAssembly原理与核心技术  |                | tip  |
| 2  | 二进制格式必须按照ID自增顺序出现，文本格式下没有这个限制                       | WebAssembly原理与和信心技术 |                | tip  |
| 3  | 数值计算溢出一共有3种处理方式，分别是：1.环绕 2.饱和 3.异常，为了减少异常，增加饱和截断指令  | WebAssembly原理与核心技术  |                | tip  |
| 4  | Wasm的函数可以分为3类：1.内部函数 2.外部                           | WebAssembly原理与核心技术  |                | tip  |
| 5  | 外部函数分为普通函数和本地函数，普通函数和内部函数区别不大，本地函数一般是其他语言编译成Wasm的函数 | WebAssembly原理与核心技术  |                | tip  |
| 6  | Wasm不支持任意跳转指令                                       | WebAssembly原理与核心技术  |                | tip  |
| 7  | Wasm采用类型安全的操作数栈以及接过话控制指令和受限跳转指令，是的函数的字节码可以在线性时间内验证  | WebAssembly原理与核心技术  |                | tip  |
| 8  | wasm2wat --fold-exprs 产生易读的WAT文件，可以折叠表达式            | WebAssembly原理与核心技术  |                | tip  |
| 9  | Java9引入了AOT编译器，可以将Java字节码编译成本地代码                    | WebAssembly原理与核心技术  |                | tip  |
| 10 | https://github.com/WebAssembly/proposals            | WebAssembly原理与核心技术  | WebAssembly 提案 | page |


> Wasm 指令表

|      助记符      | 操作码  | 操作数 | 说明                  |
|:-------------:|:----:|:---:|:--------------------|
|  unreachable  | 0x00 |  0  | 执行到这条指令时，程序会立即终止    |
|      nop      | 0x01 |  0  | 什么都不做               |
|     block     | 0x02 |  1  | 创建一个块，块的类型由操作数指定    |
|     loop      | 0x03 |  1  | 创建一个循环块，块的类型由操作数指定  |
|      if       | 0x04 |  1  | 创建一个条件块，块的类型由操作数指定  |
|     else      | 0x05 |  0  | else块，用于if块之后       |
|      end      | 0x0b |  0  | 块结束                 |
|      br       | 0x0c |  1  | 无条件跳转到指定的块          |
|     br_if     | 0x0d |  1  | 如果操作数为真，则跳转到指定的块    |
|   br_table    | 0x0e |  2  | 根据操作数的值跳转到指定的块      |
|    return     | 0x0f |  0  | 函数返回                |
|     call      | 0x10 |  1  | 调用函数                |
| call_indirect | 0x11 |  2  | 间接调用函数              |
|     drop      | 0x1a |  0  | 丢弃栈顶的值              |
|    select     | 0x1b |  0  | 根据栈顶的值选择两个值中的一个     |
|   get_local   | 0x20 |  1  | 获取局部变量              |
|   set_local   | 0x21 |  1  | 设置局部变量              |
|   tee_local   | 0x22 |  1  | 设置局部变量，并将值复制到栈顶     |
|  get_global   | 0x23 |  1  | 获取全局变量              |
|  set_global   | 0x24 |  1  | 设置全局变量              |
|   i32.load    | 0x28 |  1  | 从内存中加载一个32位整数       |
|   i64.load    | 0x29 |  1  | 从内存中加载一个64位整数       |
|   f32.load    | 0x2a |  1  | 从内存中加载一个32位浮点数      |
|   f64.load    | 0x2b |  1  | 从内存中加载一个64位浮点数      |
|  i32.load8_s  | 0x2c |  1  | 从内存中加载一个8位有符号整数     |
|  i32.load8_u  | 0x2d |  1  | 从内存中加载一个8位无符号整数     |
| i32.load16_s  | 0x2e |  1  | 从内存中加载一个16位有符号整数    |
| i32.load16_u  | 0x2f |  1  | 从内存中加载一个16位无符号整数    |
|  i64.load8_s  | 0x30 |  1  | 从内存中加载一个8位有符号整数     |
|  i64.load8_u  | 0x31 |  1  | 从内存中加载一个8位无符号整数     |
| i64.load16_s  | 0x32 |  1  | 从内存中加载一个16位有符号整数    |
| i64.load16_u  | 0x33 |  1  | 从内存中加载一个16位无符号整数    |
| i64.load32_s  | 0x34 |  1  | 从内存中加载一个32位有符号整数    |
| i64.load32_u  | 0x35 |  1  | 从内存中加载一个32位无符号整数    |
|   i32.store   | 0x36 |  1  | 将一个32位整数存储到内存中      |
|   i64.store   | 0x37 |  1  | 将一个64位整数存储到内存中      |
|   f32.store   | 0x38 |  1  | 将一个32位浮点数存储到内存中     |
|   f64.store   | 0x39 |  1  | 将一个64位浮点数存储到内存中     |
|  i32.store8   | 0x3a |  1  | 将一个8位整数存储到内存中       |
|  i32.store16  | 0x3b |  1  | 将一个16位整数存储到内存中      |
|  i64.store8   | 0x3c |  1  | 将一个8位整数存储到内存中       |
|  i64.store16  | 0x3d |  1  | 将一个16位整数存储到内存中      |
|  i64.store32  | 0x3e |  1  | 将一个32位整数存储到内存中      |
|  memory.size  | 0x3f |  0  | 获取内存的大小             |
|  memory.grow  | 0x40 |  1  | 增加内存的大小             |
|   i32.const   | 0x41 |  1  | 将一个32位整数压入栈顶        |
|   i64.const   | 0x42 |  1  | 将一个64位整数压入栈顶        |
|   f32.const   | 0x43 |  1  | 将一个32位浮点数压入栈顶       |
|   f64.const   | 0x44 |  1  | 将一个64位浮点数压入栈顶       |
|    i32.eqz    | 0x45 |  0  | 判断栈顶的值是否为0          |
|    i32.eq     | 0x46 |  0  | 判断栈顶的两个值是否相等        |
|    i32.ne     | 0x47 |  0  | 判断栈顶的两个值是否不相等       |
|   i32.lt_s    | 0x48 |  0  | 判断栈顶的第二个值是否小于第一个值   |
|   i32.lt_u    | 0x49 |  0  | 判断栈顶的第二个值是否小于第一个值   |
|   i32.gt_s    | 0x4a |  0  | 判断栈顶的第二个值是否大于第一个值   |
|   i32.gt_u    | 0x4b |  0  | 判断栈顶的第二个值是否大于第一个值   |
|   i32.le_s    | 0x4c |  0  | 判断栈顶的第二个值是否小于等于第一个值 |
|   i32.le_u    | 0x4d |  0  | 判断栈顶的第二个值是否小于等于第一个值 |
|   i32.ge_s    | 0x4e |  0  | 判断栈顶的第二个值是否大于等于第一个值 |
|   i32.ge_u    | 0x4f |  0  | 判断栈顶的第二个值是否大于等于第一个值 |
|    i64.eqz    | 0x50 |  0  | 判断栈顶的值是否为0          |
|    i64.eq     | 0x51 |  0  | 判断栈顶的两个值是否相等        |
|    i64.ne     | 0x52 |  0  | 判断栈顶的两个值是否不相等       |
|   i64.lt_s    | 0x53 |  0  | 判断栈顶的第二个值是否小于第一个值   |
|   i64.lt_u    | 0x54 |  0  | 判断栈顶的第二个值是否小于第一个值   |
|   i64.gt_s    | 0x55 |  0  | 判断栈顶的第二个值是否大于第一个值   |
|   i64.gt_u    | 0x56 |  0  | 判断栈顶的第二个值是否大于第一个值   |
|   i64.le_s    | 0x57 |  0  | 判断栈顶的第二个值是否小于等于第一个值 |
|   i64.le_u    | 0x58 |  0  | 判断栈顶的第二个值是否小于等于第一个值 |
|   i64.ge_s    | 0x59 |  0  | 判断栈顶的第二个值是否大于等于第一个值 |
|   i64.ge_u    | 0x5a |  0  | 判断栈顶的第二个值是否大于等于第一个值 |
|    f32.eq     | 0x5b |  0  | 判断栈顶的两个值是否相等        |
|    f32.ne     | 0x5c |  0  | 判断栈顶的两个值是否不相等       |
|    f32.lt     | 0x5d |  0  | 判断栈顶的第二个值是否小于第一个值   |
|    f32.gt     | 0x5e |  0  | 判断栈顶的第二个值是否大于第一个值   |
|    f32.le     | 0x5f |  0  | 判断栈顶的第二个值是否小于等于第一个值 |
|    f32.ge     | 0x60 |  0  | 判断栈顶的第二个值是否大于等于第一个值 |
|    f64.eq     | 0x61 |  0  | 判断栈顶的两个值是否相等        |
|    f64.ne     | 0x62 |  0  | 判断栈顶的两个值是否不相等       |
|    f64.lt     | 0x63 |  0  | 判断栈顶的第二个值是否小于第一个值   |
|    f64.gt     | 0x64 |  0  | 判断栈顶的第二个值是否大于第一个值   |
|    f64.le     | 0x65 |  0  | 判断栈顶的第二个值是否小于等于第一个值 |
|    f64.ge     | 0x66 |  0  | 判断栈顶的第二个值是否大于等于第一个值 |
